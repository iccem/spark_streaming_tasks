Spark Streaming

Task 1
Скрипт извлекает коллокации из корпуса текстов (статьи Википедии). 
Коллокация - два последовательно стоящих слова (пара слов), которые чаще других встречаются вместе. Например, «references_external» или «Roman Empire».

Для поиска коллокаций используется метрика NPMI (нормализованная точечная взаимная информация).


Порядок работы

PMI двух слов a и b определяется как:

PMI(a,b) = ln(P(a,b) / P(a)∗P(b)),

где P(ab) - вероятность двух слов, идущих подряд, а P(a) и P (b) - вероятности слов a и b соответственно.
Чем больше значение PMI, тем реже встречается коллокация.


Оцениваем вероятности встречаемости слов:
число вхождений каждого слова разделим на общее число слов в корпусе

P(a) = num_of_occurrences_of_word_"a" / num_of_occurrences_of_all_words

P(ab) = num_of_occurrences_of_pair_"ab" / num_of_occurrences_of_all_pairs

total_number_of_words - общее кол-во слов в тексте
total_number_of_word_pairs - общее кол-во пар

Расчет NPMI:

NPMI(a,b) = −(PMI(a,b) / lnP(a,b))

Нормализуем величину в диапазон [-1; 1].


Обработка данных

При парсинге отбрасываются все символы, которые не являются латинскими буквами.
Все слова приводятся к нижнему регистру.
Удаляются "стоп-слова", в том числе внутри биграмм, например, “at evening” имеет ту же семантику что и “at the evening”, список "слоп-слов" прилагается.
Биграммы при выводе объединяются символом нижнего подчеркивания "_".
Считается NPMI только для биграмм, которые встретились чаще 500 раз.
Общее число слов и биграмм считаются до фильтрации.

На экран выводится (в STDOUT) TOP-39 самых популярных коллокаций, отсортированных по убыванию значения NPMI. Само значение NPMI  не выводится.



Task 2

Spark Streaming

Входные данные: /data/realtime/uids
Формат данных:
...
seg_firefox 4176
...

Условие
Сегмент - это множество пользователей, определяющееся неким признаком. Когда пользователь посещает web-сервис со своего устройства, это событие логируется на стороне web-сервиса в следующем формате: user_id <tab> user_agent. Например:

f78366c2cbed009e1febc060b832dbe4	Mozilla/5.0 (Linux; Android 4.4.2; T1-701u Build/HuaweiMediaPad) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.73 Safari/537.36
62af689829bd5def3d4ca35b10127bc5	Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36


На вход поступают порции web-логов в описанном формате. Требуется разбить аудиторию (пользователей) в этих логах на следующие сегменты:

Пользователи, которые работают в интернете из-под IPhone.
Пользователи, кот. используют Firefox браузер.
Пользователи, кот. используют Windows.

Не стоит волноваться если какие-то пользователи не попадут ни в 1 из указанных сегментов поскольку в реальной жизни часто попадаются данные, которые сложно классифицировать. Таких пользователей просто не включаем в выборку.
Также сегменты могут пересекаться (ведь возможен вариант, что пользователь использует Windows, на котором стоит Firefox). Для того, чтоб выделить сегменты можно использовать следующие эвристики (или придумать свои):



Сегмент
Эвристика




seg_iphone
parsed_ua['device']['family'] like '%iPhone%'


seg_firefox
parsed_ua['user_agent']['family'] like '%Firefox%'


seg_windows
parsed_ua['os']['family'] like '%Windows%'



Оцените кол-во уникальных пользователей в каждом сегменте используя алгоритм 
HyperLogLog (error_rate равным 1%).

В результате выведите сегменты и количества пользователей в следующем формате: segment_name <tab> count. Отсортируйте результат по количеству пользователей в порядке убывания.
